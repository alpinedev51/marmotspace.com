---
title: "Buffer Overflow Exploit"
publishedAt: "2025-08-30"
summary: "An explanation of buffer overflow and a basic buffer overflow expliot."
category: 'lesson'
subject: 'dev'
author: 'AlpineDev'
---

Hello, in this post I will be going over basics of _buffer overflows_ and vulnerabilities/exploits related to them. We will be going over a the fundamentals about buffer overflows, how you can exploit the buffer overflow to do things like control hijacking. We will be going a bit more in depth than just the C level code by taking a look at the assembly equivalent code for the C programs and analyzing the flow of execution and state of data in memory.

# Buffer Overflow

A buffer is just any allocated space in memory where data can be stored. C doesn't validate the when you index a buffer it lies within the bounds of the initialized buffer. Hence, we can exploit this.

Buffers can be local variables, global variables, or dynamically allocated on the heap using `malloc` or `calloc`.

A **Buffer Overflow** is a vulnerability in which data can be written which exceeds the allocated space, allowing an attacker to overwrite other data.

## Stack buffer overflow

The simples and most common buffer overflow is one where the buffer is on the stack.

```c
#include <stdio.h>

int main() {
	int secret = 0xdeadbeef;
	char name[100] = {0};
	read(0, name, 0x100); // <-- anything wrong with this?
	if (secret == 0x1337) {
		puts("Wow! Here's a secret.");
	} else {
		puts("I guess you're not cool enough to see my secret.");
	}
}
```

1. Memory layout of the stack frame

When `main` is called, the compiler sets up a stack frame that looks roughly like this (addresses grow downward):

```
[ higher addresses ]
...
saved EBP / return address
secret (4 bytes, int)
name[100] (100 bytes, char array)
[ lower addresses ] < -- ESP
```

In memory, the local buffer `name` is **below** (lower in memory) the variable `secret`.

2. The dangerous function call

```c
read(0, name, 0x100);
```

- `read` is a system call that reads raw bytes from the file descriptor 0 (stdin).
- It takes a buffer pointer (`name`) and a size (`0x100` = 256 bytes).
- That means: _Please put up to 256 bytes from stdin into the 100-byte buffer `name`_.

**Problem:** The buffer `name` only has space for 100 bytes, but the program tells `read` it's okay to write up to 256 bytes.

This is undefined behavior: if more than 100 bytes are actually read, `read` will keep writing, clobbering anything that lies after `name` in memory - including the saved EBP, return address, `secret`, and more!

3. How the overflow is exploitable

If the attacker enters more than 100 characters, those extra characters will overwrite the bytes holding `secret`.
- Normally, `secret = 0xdeadbeef`.
- But if the attacker inputs carefully crafted bytes, they can make `secret = 0x1337`.

For exmaple, if you input 100 "A"s (`0x41`) followed by `0x37 0x13 0x00 0x00` (little-endian encoding of `0x1337`), you overwrite `secret` with the desired value.

This is because `secret` is a local variable and is stored on the stack just as the buffer is. Specifically, `secret` exists above the buffer in the stack.

Now the condition:

```c
if (secret == 0x1337) {
	puts("Wow! Here's a secret.");
}
```

will succeed - diving the attacker access to a code path they shouldn't have.

# Takeaways

The core bug is that the program trusts the size argument to `read` rather than ensuring it matches the actual buffer size. This may remind of SQL injections, XSS, as well as other exploits. Data sanitation and validation is really important! And in this case, using a language like Rust would prevent this entirely.

Safer code would look like:

```c
read(0, name, sizeof(name));
```

That way, the input is capped at 100 bytes &mdash; no overwriting of `secret`.

# How Rust Prevents This

Rust prevents buffer overflow exploits through a combination of compile-time and run-time checks.

## The Core Mechanism: Ownership and Borrowing

At the heart of Rust's memory safety model is the concept of ownership. Every value in Rust has a single "owner." When the owner goes out of scope, the value is automatically deallocated. This system eliminates the possibility of dangling pointers and double-free bugs, which are common precursors to memory-based exploits.

Furthermore, Rust's borrow checker enforces strict rules about how data can be accessed. A "borrow" is a temporary reference to a value, and the borrow checker ensures that:

- You can have multiple immutable borrows (read-only references) at the same time.
- You can have only one mutable borrow (a read-write reference) at a time.
- You cannot have a mutable borrow while there are any immutable borrows.

This strict enforcement, verified at compile time, prevents data races and other forms of undefined behavior that could lead to a buffer overflow.

## Indexed Access and Bound Checks

The most direct way Rust prevents buffer overflows is through its handling of indexed access to collections like arrays and vectors. When you try to access an element using an index, such as my_array[i], Rust performs an automatic bounds check. This means the program verifies that the index i is within the valid range of the array's length.

If the index is out of bounds, the program will not continue into a state of undefined behavior. Instead, it will "panic" and terminate with a clear error message. While a program crash is not ideal, it is far safer than a malicious actor being able to write data to an unintended memory location, which is the hallmark of a buffer overflow attack.

Here are two direct examples:

1. Slices carry their length, and I/O APIs use them

In C, we wrote `read(0, name, 0x100)` &mdash; we told the OS to write 256 bytes into a 100-byte array. Rust flips that around:

```rust
use std::io::{self, Read};

fn main() -> io::Result<()> {
	let mut buf = [0u8; 100];
	// read() takes &mut [u8] - a slice with a known length (100 here).
	let n = io::stdin().read(&mut buf)?; // never writes more than buf.len()
	println!("Read {} bytes", n);
	Ok(())
}
```

2. Indexing is bounds-checked

If you index or slice beyond bounds, Rust **panics** (aborts the operation) rather than corrupting memory:

```rust
let x = buf[100]; // panic at runtime (index out of bounds), not UB.
```

Compilers often remove redundant bounds checks when they can prove safety, but the semantic guarantee remains.




