---
title: "Understanding Buffer Overflow Exploits"
publishedAt: "2025-08-30"
summary: "A deep dive into buffer overflows: what they are, how they happen, their assembly-level behavior on x86-64 Linux, and how attackers exploit them."
category: 'lesson'
subject: 'cybersecurity'
author: 'AlpineDev'
---

# Introduction

Buffer overflows are one of the most classic and impactful vulnerabilities in computer security. They arise from a simple bug: writing more data into a buffer than it can hold. Yet this simple bug can let attackers hijack control flow, leak secrets, or even execute arbitrary code.

In this post, we’ll:
- Explain what a buffer overflow is.  
- Walk through a motivating C example.  
- Translate the example into its x86-64 Linux assembly form.  
- Analyze the flow of execution and stack layout.  
- Explore common exploit techniques that build on buffer overflows.  
- Compare how modern safe languages like Rust prevent these issues.

---

# What is a Buffer Overflow?

A **buffer** is just a contiguous region of memory for holding data (e.g. an array of characters). In C, when you write to an array, the compiler and runtime do **not** check whether the index lies within the allocated bounds.

A **buffer overflow** occurs when you write past the end of the buffer, corrupting nearby memory. Depending on where the buffer is allocated, you can clobber local variables, control data on the stack (saved return addresses), heap metadata, or global data.

---

# A Motivating Example in C

Let’s look at a simple but vulnerable C program ([source](https://ctf101.org/binary-exploitation/buffer-overflow/)):

```c
#include <stdio.h>
#include <unistd.h>

int main() {
    int secret = 0xdeadbeef;
    char name[100] = {0};

    read(0, name, 0x100); // <-- unsafe

    if (secret == 0x1337) {
        puts("Wow! Here's a secret.");
    } else {
        puts("I guess you're not cool enough to see my secret.");
    }
}
```

**What’s wrong here?**

* `name` is only 100 bytes.
* But the program asks `read` to write up to `0x100` (256) bytes into it.
* If the user types more than 100 bytes, the extra bytes will overwrite memory beyond `name`.

Specifically, `secret` lives just above `name` on the stack. By overflowing `name`, we can overwrite `secret`.

For example, sending:

```
"A" * 100 + "\x37\x13\x00\x00"
```

overwrites `secret` with `0x1337`, unlocking the "secret" branch of code.

---

# Stack Layout and Memory Flow

On Linux x86-64 with typical compilation, the stack frame for `main` looks roughly like this (addresses grow downward):

```
[ lower addresses ] <-- RSP
Padding (to maintain 16-byte alignment)
name[100] (100 bytes)
secret (4 bytes, padded to 8 for alignment)
Saved RBP
Return address
[ higher addresses ]
```

Key detail: local variables are placed relative to RBP. The array `name` is allocated at a lower address, so overflowing it writes *upward in memory*, into `secret`, and if unchecked, into saved RBP and even the return address.

---

# Assembly Equivalent (x86-64, Linux, gcc -O0)

Here’s a representative disassembly (simplified for clarity):

```asm
main:
    push    rbp
    mov     rbp, rsp
    sub     rsp, 0x80        ; reserve stack space

    mov     DWORD PTR [rbp-0x4], 0xdeadbeef ; secret
    lea     rax, [rbp-0x70]  ; address of name[0]
    mov     edx, 0x100       ; count = 256
    mov     rsi, rax         ; buf = &name
    mov     edi, 0x0         ; fd = stdin
    call    read

    cmp     DWORD PTR [rbp-0x4], 0x1337
    jne     .Lelse
    lea     rdi, [rip+msg1]
    call    puts
    jmp     .Ldone
.Lelse:
    lea     rdi, [rip+msg2]
    call    puts
.Ldone:
    leave ; mov rsp, rbp, then pop rbp
    ret
```

Notice:

* `secret` lives at `[rbp-0x4]`.
* `name` starts at `[rbp-0x70]`.
* Overflowing `name` by >100 bytes will overwrite `[rbp-0x4]` (secret), and then the saved RBP, then the return address.

---

# From Vulnerability to Exploit

The above is a **stack buffer overflow**, the most famous type. Let’s look at what attackers can do:

### 1. Variable Corruption

As shown, overwrite `secret` to alter program logic.

### 2. Return Address Overwrite

If you keep writing beyond local variables, you can overwrite the **saved return address**. When the function returns, execution jumps to attacker-controlled data. This enables **code injection** (old-school shellcode attacks).

### 3. Return-to-libc (ret2libc)

Modern OSes prevent execution on the stack (DEP / NX bit). Attackers instead overwrite the return address with the address of a libc function like `system("/bin/sh")`. This is **return-to-libc**.

### 4. ROP (Return-Oriented Programming)

Even stronger defenses (ASLR, PIE) make ret2libc harder. Attackers chain “gadgets” (small instruction sequences ending in `ret`) already present in the binary/libc. This is **ROP**, a general technique for arbitrary computation.

### 5. Heap Overflows

Similar logic applies on the heap, corrupting allocator metadata (tcache, fastbins, etc.) to achieve arbitrary write.

---

# Defensive Measures

* **Compiler protections:**

  * Stack canaries (detect corruption of return addresses).
  * Position Independent Executables (PIE) + ASLR (randomize addresses).
  * NX bit (non-executable stack).

* **Safer functions/APIs:**

  * Always use `sizeof(buffer)` instead of hardcoded values.
  * Use `fgets`, `strncpy`, or bounded I/O functions.

---

# Safer Code in C

```c
read(0, name, sizeof(name)); // safe: only reads 100 bytes max
```

---

# Why Rust Prevents This

Rust (mostly) eliminates this entire class of vulnerabilities:

* **Ownership & Borrowing** ensure memory safety at compile time.
* **Bounds checks** on array/vector indexing prevent out-of-bounds writes.
* I/O functions take slices (which carry length), so you can’t lie about buffer size:

```rust
use std::io::{self, Read};

fn main() -> io::Result<()> {
    let mut buf = [0u8; 100];
    let n = io::stdin().read(&mut buf)?; // safe: capped at 100
    println!("Read {} bytes", n);
    Ok(())
}
```

Out-of-bounds attempts result in a **panic** (safe crash), not memory corruption.

---

# Conclusion

Buffer overflows remain foundational in security:

* They teach why low-level memory safety matters.
* They illustrate how attackers escalate from a simple bug to arbitrary code execution.
* They motivate modern mitigations (DEP, ASLR, canaries).
* They show why languages like Rust provide strong protection out of the box.

Even today, advanced exploits (ROP, JOP, heap feng shui) are just descendants of the same ancient vulnerability: writing past the end of a buffer.
